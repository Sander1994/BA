\section{Implementierung}
In diesem Kapitel wird die Implementierung des Projektes vorgestellt und erläutert. Zur Darstellung der Funktionsweise der einzelnen Funktionen wird Pseudocode verwendet. Dies soll dabei helfen die Funktionsweise verständlicher und knapper aufzuzeigen.
\subsection{Spielumgebung}
Die Implementierung besteht aus zwei wesentlichen Klassen. Eine davon ist die Spielumgebung. Zunächst werden in diesem Kapitel die wesentlichen Attribute der Spielumgebung und anschließend ihre Methoden erläutert.
\subsubsection{Klassenattribute}
\begin{minipage}{\linewidth}
Der folgende Code zeigt die Klassenattribute, die für das Rundenmanagement wichtig sind:
\vspace{0.5cm}
\begin{lstlisting}
self.initial_rounds
self.rounds
self.roll_in_round
\end{lstlisting}
Code 1: Klassenattribute für Runden\\
\end{minipage}

Das Attribut initial\_rounds beschreibt die maximale Rundenanzahl des Spiels und wird beim Zurücksetzen der Umgebung verwendet, um die Rundenzahl auf den gewünschten Wert (im solo Spiel sechs) zu zurückzusetzen.

Das Attribut rounds repräsentiert die aktuell verbleibende Rundenanzahl im Spiel.

Das Attribut roll\_in\_round repräsentiert die Nummer des aktuellen Wurfes in der Runde.\\

\begin{minipage}{\linewidth}
Der folgende Code zeigt die Klassenattribute, die für das Würfeln der Würfel relevant sind:
\vspace{0.5cm}
\begin{lstlisting}
self.invalid_dice = {"white": False, "yellow": False, ...}
self.dice = {"white": 0, "yellow": 0, ...}
\end{lstlisting}
Code 2: Klassenattribute für Würfel\\
\end{minipage}

Die Attribute invalid\_dice und dice repräsentieren die Augenzahlen der Würfel, sowie die Gültigkeit der Würfel selbst. Ist der Wert von invalid\_dice False, ist der Würfel nicht ungültig und somit gültig.\\

\begin{minipage}{\linewidth}
Der folgende Code zeigt die Klassenattribute, die für das bilden einer Punktestandhistorie relevant sind:
\vspace{0.5cm}
\begin{lstlisting}
self.score
self.score_history
self.initialized
\end{lstlisting}
Code 3: Klassenattribute für Punktestand\\
\end{minipage}

Das Attribut score repräsentiert den aktuellen Score der Spielumgebung. Es wird verwendet, um erreichte Punktestände in die score\_history einzutragen. Das Attribut score\_history ist eine Historie über die erreichten Punktestände in den Episoden beziehungsweise Spieldurchläufen beim Training. Das Attribut initialized wird verwendet, um zu gewährleisten, dass nur Einträge in der Score-History eingetragen werden, nachdem ein Spiel abgeschlossen worden ist. Es trifft eine Aussage darüber ob die Spielumgebung bereits einmal initialisiert worden ist oder nicht.\\

\begin{minipage}{\linewidth}
Der folgende Code zeigt die Klassenattribute, welche die farbigen Felder des Spielbrettes repräsentieren:
\vspace{0.5cm}
\begin{lstlisting}
self.yellow_field = [[3, 6, 5, 0], [2, 1, 0, 5], [1, 0, 2, 4], ...]
self.blue_field = [[0, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]
self.green_field = [0] * 11
self.orange_field = [0] * 11
self.purple_field = [0] * 11
\end{lstlisting}
Code 4: Klassenattribute für farbige Felder\\
\end{minipage}

Die Attribute yellow\_field, blue\_field, green\_field, orange\_field und purple\_field stehen für die fünf farbigen Felder auf dem Spielbrett. Sie repräsentieren die eingetragenen Werte auf dem Spielbrett und bestimmen somit welche Kästchen aktuell ausgefüllt werden können (vorausgesetzt die Würfelergebnisse passen) und welche Belohnungen freigeschaltet werden beziehungsweise freigeschaltet worden sind.\\

\begin{minipage}{\linewidth}
Der folgende Code zeigt die Klassenattribute, welche die zu erspielenden Boni auf den farbigen Feldern repräsentieren:
\vspace{0.5cm}
\begin{lstlisting}
self.yellow_rewards = {"row": ["blue_cross", ...], "dia": ...}
self.blue_rewards = {"row": ["orange_five", ...], "col": ...}
self.green_rewards = [None, None, None, "extra_pick", ...]
self.orange_rewards = [None, None, "re_roll", ...]
self.purple_rewards = [None, None, "re_roll", "blue_cross", ...]
\end{lstlisting}
Code 5: Klassenattribute für freizuschaltende Boni\\
\end{minipage}

Die Attribute yellow\_rewards, blue\_rewards, green, orange\_rewards und purple\_rewards repräsentieren die freizuschaltenden Boni für die jeweiligen farbigen Felder. Für das blaue Feld sind diese in Form von Reihen (row) und Spalten (col) aufgeführt. Das gelbe Feld besitzt Boni für das ausfüllen von Reihen (row) und einen Boni, der bei diagonalem ausfüllen (dia) freigeschaltet werden kann. Für die Farben grün, orange und lila sind die Boni jeweils direkt einem der Kästchen im Feld zugewiesen, wobei viele der Kästchen keinen freizuschaltenden Boni aufweisen, was dem Wert None entspricht.\\

\begin{minipage}{\linewidth}
Der folgende Code zeigt die Klassenattribute, für die Punktebelohnungen des gelben, blauen und grünen Feldes:
\vspace{0.5cm}
\begin{lstlisting}
self.yellow_rewards = {"col": [10, 14, 16, 20], ...}
self.blue_count_rewards = [0, 1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
self.green_count_rewards = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
\end{lstlisting}
Code 6: Klassenattribute für Punktestand\\
\end{minipage}

Im Attribut yellow\_rewards sind im Spaltenbereich (col) die Punktebelohnungen des gelben Feldes aufgeführt. Die Attribute blue\_count\_rewards und green\_count\_rewards repräsentieren die Punktebelohnungen, welche erspielt werden können sobald ein blaues beziehungsweise grünes Kästchen ausgefüllt wird. Beginnend vom ersten Wert des Arrays und danach inkrementell aufsteigend, steigt die erhaltene Punktebelohnung bei jedem ausgefüllten Kästchen stetig an.\\

\begin{minipage}{\linewidth}
Der folgende Code zeigt die Klassenattribute der Flags für die Belohnungen der farbigen Felder. Sind diese gesetzt und sind die entsprechenden Kästchen für die Belohnung ausgefüllt, wurde die Belohnung bereits ausgeschüttet und wird es nicht erneut, bis sie nach dem Spiel wieder zurückgesetzt werden:
\vspace{0.5cm}
\begin{lstlisting}
self.yellow_reward_flags = {"row": [False] * 4, "col": ...}
self.blue_reward_flags = {"row": [False] * 3, "col": [False] * 4}
self.blue_count_reward_flags = [False] * 12
self.green_reward_flags = [False] * 11
self.orange_reward_flags = [False] * 11
self.purple_reward_flags = [False] * 11
\end{lstlisting}
Code 7: Klassenattribute für Belohnungsflags\\
\end{minipage}

\begin{minipage}{\linewidth}
Der folgende Code zeigt die Klassenattribute für Punktestände der einzelnen farbigen Felder. Die Punktewerte werden aufaddiert, sobald Punkte im entsprechenden Feld erzielt worden sind und am Ende genutzt, um den Wert der Fuchs Boni zu bestimmen [siehe Grundlagen]:
\vspace{0.5cm}
\begin{lstlisting}
self.yellow_field_score
self.blue_field_score
self.green_field_score
self.orange_field_score
self.purple_field_score
\end{lstlisting}
Code 8: Klassenattribute für Punktestände der Felder\\
\end{minipage}

\begin{minipage}{\linewidth}
Der folgende Code zeigt die Klassenattribute für freigeschaltete Boni. Wird eine Boni erspielt wird der Wert inkrementiert, wird sie genutzt wird er dekrementiert:
\vspace{0.5cm}
\begin{lstlisting}
self.extra_pick
self.re_roll
self.fox
self.yellow_cross
self.blue_cross
self.green_cross
self.orange_four
self.orange_five
self.orange_six
self.purple_six
\end{lstlisting}
Code 9: Klassenattribute für freigespielte Boni\\
\end{minipage}

\begin{minipage}{\linewidth}
Der folgende Code zeigt die Klassenattribute für die Anzahl an gewählten Kästchen in den verschiedenen farbigen Feldern. Wenn ein Kästchen in einem der Felder ausgefüllt wird, wird der Wert dieses Attributes inkrementiert. Diese Attribute dienen nicht dem Spielablauf selbst, sondern zur Nachvollziehbarkeit der Strategie des Modells:
\vspace{0.5cm}
\begin{lstlisting}
self.picked_yellow
self.picked_blue
self.picked_green
self.picked_orange
self.picked_purple
\end{lstlisting}
Code 10: Klassenattribute für gewählte Kästchen in den farbigen Feldern\\
\end{minipage}

\begin{minipage}{\linewidth}
Der folgende Code zeigt die Klassenattribute für den Aktions- sowie Beobachtungsraum:
\vspace{0.5cm}
\begin{lstlisting}
self.number_of_actions = 247
low_bound = np.array([0]*16 + [0]*12 + ...)
high_bound = np.array([6]*16 + [6]*12 + ...)
self.action_space = spaces.Discrete(self.number_of_actions)
self.observation_space = spaces.Box(low_bound, high_bound, shape= ...
self.valid_action_mask_value = np.ones(self.number_of_actions)
\end{lstlisting}
Code 11: Klassenattribute Aktionsraum und Beobachtungsraum\\
\end{minipage}

Das Attribut number\_of\_actions repräsentiert die Gesamtanzahl an möglichen Aktionen des Modells. Die Attribute low\_bound und high\_bound setzten die obere und untere Grenze von Werten im Beobachtungsraum fest. Beispielsweise steht der erste Eintrag in beiden für Werte des gelben Feldes. Diese können von null ([0]*16) bis sechs ([6]*16) reichen. Das Attribut action\_space repräsentiert den Aktionsraum des Modells. Es ist ein Diskreter Raum mit number\_of\_actions Werten von null bis number\_of\_actions minus eins. Das Attribut observation\_space repräsentiert den Beobachtungsraum. Shape definiert dabei die Größe des Beobachtungsraumes. Das Attribut valid\_action\_mask\_value repräsentiert die Aktionsmaske. Initial handelt es sich dabei um ein Numpy Array aus Einsen. Einsen stehen für gültige Aktionen, Nullen für ungültige. Die Werte verlaufen parallel zu den Werten des Aktionsraumes. Somit repräsentieren alle Werte (beispielsweise [0] oder [5]) sowohl im Aktionsraum als auch bei der Aktionsmaske die selbe Aktion.\\

Die Struktur des Aktionsraumes ist für das Verständnis der Arbeit wichtig, daher wird sie hier erläutert:

Die ersten 122 Werte des Aktionsraumes von 0 bis 121 sind sowohl normalen Wahlen bei eigenen Würfen als auch den verschiedenen Boni, welche es ermöglichen direkt ein Kästchen eines Felder anzukreuzen, zugeordnet. Dabei stehen die ersten 16 Werte für Kästchen des gelben Feldes, die nächsten 12 für Kästchen des blauen Feldes, und die folgenden 33 zu einer Aufteilung von jeweils 11 für Kästchen im grünen, orangenen und lila Feld. Die Werte von 61 bis 121 stehen für die selben Kästchen in der selben Reihenfolge wie die vorherigen 61 Werte, allerdings wird bei diesen der weiße Würfel verwendet statt des jeweils farbigen für das spezifische Feld.

Die Werte von 122 bis 243 stehen für Wahlen mit der Extra Wahl Boni oder für Wahlen vom Silbertablett des Gegners. Die Struktur innerhalb dieser Reichweite ist die selbe wie bei den 122 Werte davor. Die ersten 16 Werte stehen für die selben Kästchen im gelben Feld und so weiter.

Der Wert 244 steht für die Neu Würfeln Boni, der Wert 245 für das passen bei einem möglichen Einsatz der Extra Wahl Boni und der Wert 246 für eine ungültige Aktion, die nur möglich ist, wenn keine der anderen Aktionen getätigt werden kann.
\subsubsection{Schritt Methode}
Der folgende Pseudocode zeigt die Funktionsweise der Schritt Methode (step method) der Spielumgebung. Diese Methode führt Spielschritte beziehungsweise Aktionen in der Spielumgebung aus:
\vspace{0.5cm}
\begin{lstlisting}
step(Aktion):
	Setze Methodenattribute zurück
	
	if not Extrapickaktion:
		if Aktion im gelben Feld:
			Fülle entsprechendes gelbes Kästchen aus
			if Gelbes Kreuz Boni >= 1
				Bonusrunde = True
				Gelbes Kreuz -= 1
			if not Bonusrunde:
				Setze entsprechende Würfel auf ungültig
		if Aktion im blauen Feld:
			Fülle entsprechendes blaues Kästchen aus
			if Blaues Kreuz Boni >= 1:
				Bonusrunde = True
				Blaues Kreuz -= 1
			if not Bonusrunde:
				Setze entsprechende Würfel auf ungültig
		if Aktion im grünen Feld:
			Fülle entsprechendes grünes Kästchen aus
			if Grünes Kreuz Boni >= 1:
				Bonusrunde = True
				Grünes Kreuz -= 1
			if not Bonusrunde:
				Setze entsprechende Würfel auf ungültig
		if Aktion im orangene Feld:
			Fülle entsprechendes orangenes Kästchen aus
			if Orangene Feld Boni >= 1:
				Bonusrunde = True
				Orangene Feld Boni -= 1
			if not Bonusrunde:
				Setze entsprechende Würfel auf ungültig
		if Aktion im lila Feld:
			Fülle entsprechendes lila Kästchen aus
			if Lila Sechs Boni >= 1:
				Bonusrunde = True
				Lila Sechs Boni -= 1
			if not Bonusrunde:
				Setze entsprechende Würfel auf ungültig
	
	if Extrapickaktion:
		Bonusrunde = True
		if Extra Wahl Boni benutzt:
			Extra Wahl Boni -= 1
		Finde Kästchen zum ausfüllen und fülle es aus
		Setze gewählten Würfel auf ungültig
		if Extra Wahl Boni <= 0 or Wahl erfolgte vom Silbertablett:
			Runde wird inkrementiert
			
	if Neu Würfeln Boni wird benutzt:
		Würfle Würfel neu
		Neu Würfeln Boni -= 1
		Aktualisiere Aktionsmaske
		return Beobachtungsraum, Punktebelohnung, Spiel terminiert?
		
	if Statt Extra Wahl Boni gepasst wird:
		Runde wird inkrementiert
		return Beobachtungsraum, Punktebelohnung, Spiel terminiert?
	if ungültige Aktion gewählt da keine gültigen Aktionen vorhanden:
		Nichts tun
			
	Punktebelohnung += erspielte Belohnung in diesem Zug
	if not Bonusrunde:
		Runde wird inkrementiert
		if Rundenanzahl == 0:
			terminiert = True
			Punktebelohnung += Fuchsbonipunktebelohnung
	Aktualisiere Aktionsmaske
	return Beobachtungsraum, Punktebelohnung, Spiel terminiert?		
\end{lstlisting}
Code 12: Schritt Methode\\

\subsubsection{Methode zum Zurücksetzen der Spielumgebung}
\begin{minipage}{\linewidth}
Der folgende Pseudocode zeigt die Funktionsweise der Methode zum Zurücksetzen der Spielumgebung (reset method). Sie setzt Umgebungen, in denen ein Spiel abgeschlossen worden ist auf den Anfangszustand zurück, damit eine weitere Runde gespielt werden kann:
\vspace{0.5cm}
\begin{lstlisting}
reset():
	Setze alle Attribute für den Spielablauf auf den Startzustand
\end{lstlisting}
Code 13: Methode zum Zurücksetzen der Umgebung\\
\end{minipage}

\subsubsection{Methode zur Visualisierung der Spielumgebung}
\begin{minipage}{\linewidth}
Der folgende Pseudocode zeigt die Funktionsweise der Funktion zur Visualisierung der Spielumgebung (render method). Die Visualisierung dient einer verbesserten Nachvollziehbarkeit der Ereignisse innerhalb der Spielumgebung:
\vspace{0.5cm}
\begin{lstlisting}
render():
	Zeige alle relevanten Attribute und Merkmale der Umgebung an
\end{lstlisting}
Code 14: Methode zur Visualisierung der Spielumgebung\\
\end{minipage}

\subsubsection{Würfel Methode}
\begin{minipage}{\linewidth}
Der folgende Pseudocode zeigt die Funktionsweise der Methode zum Würfeln der Würfel. Würfel müssen nach jedem Wurf, bei Anfang jeder Spielrunde und beim Einsetzen des Neu Würfeln Boni neu gewürfelt werden:
\vspace{0.5cm}
\begin{lstlisting}
roll_dice():
	Würfle die Werte aller gültigen Würfel neu
\end{lstlisting}
Code 15: Würfel Methode\\
\end{minipage}

\subsubsection{Methode zur Überprüfung der freigespielten Belohnungen}
\begin{minipage}{\linewidth}
Der folgende Pseudocode zeigt die Funktionsweise der Methode zur Überprüfung der freigespielten Belohnungen (check\_rewards method). Diese Methode überprüft jedes mal nachdem ein Kästchen in der Spielumgebung ausgefüllt worden ist, ob und welche Belohnung freigespielt worden ist und fügt diese dem Inventar des Spielers hinzu:
\vspace{0.5cm}
\begin{lstlisting}
check_rewards():
	Überprüfe ob im gelben Feld Belohnungen freigeschaltet wurden
	Schalte im gelben Feld freigeschaltete Belohnungen frei
	
	Überprüfe ob im blauen Feld Belohnungen freigeschaltet wurden
	Schalte im blauen Feld freigeschaltete Belohnungen frei
	
	Überprüfe ob im grünen Feld Belohnungen freigeschaltet wurden
	Schalte im grünen Feld freigeschaltete Belohnungen frei
	
	Überprüfe ob im orangenen Feld Belohnungen freigeschaltet wurden
	Schalte im orangenen Feld freigeschaltete Belohnungen frei
	
	Überprüfe ob im lila Feld Belohnungen freigeschaltet wurden
	Schalte im lila Feld freigeschaltete Belohnungen frei
	
	return Punktebelohnung
\end{lstlisting}
Code 16: Methode zur Überprüfung der freigespielten Belohnungen\\
\end{minipage}

\subsubsection{Methode zur Generierung des Beobachtungsraumes}
\begin{minipage}{\linewidth}
Der folgende Pseudocode zeigt die Funktionsweise der Methode zur Generierung des Beobachtungsraumes (\_get\_obs method). Diese Methode vereinfacht es den Beobachtungsraum zu generieren, welcher jedes mal benötigt wird, wenn ein Schritt in der Umgebung ausgeführt wird:
\vspace{0.5cm}
\begin{lstlisting}
_get_obs():
	Erstelle Numpy Arrays für farbige Felder
	Erstelle Numpy Array für Würfelergebnisse
	Erstelle Numpy Array für ungültige Würfel
	Füge Arraywerte für Boni und Rundenzahl hinzu
	Beobachtungsraum = Verbinde alle Arrays miteinander
	
	return Beobachtungsraum
\end{lstlisting}
Code 17: Methode zur Generierung des Beobachtungsraumes\\
\end{minipage}

\subsubsection{Methode zur Generierung der Aktionsmaske}
Der folgende Pseudocode zeigt Die Funktionsweise der Methode zur Generierung der Aktionsmaske (valid\_action\_mask method). Einsen stehen für gültige Aktionen und Nullen für ungültige. Die Wahlwahrscheinlichkeit des Modells für ungültige Aktionen wird auf Null gesetzt:
\vspace{0.5cm}
\begin{lstlisting}
valid_action_mask():
	Setze alle Werte auf Eins
	
	Werte für bereits ausgefüllte gelbe Kästchen = 0
	Werte für gelbe Kästchen ohne passende Würfelergebnisse = 0
	
	Werte für bereits ausgefüllte blaue Kästchen = 0
	Werte für blaue Kästchen ohne passende Würfelergebnisse = 0
	
	Werte für bereits ausgefüllte grüne Kästchen = 0
	Werte für grüne Kästchen ohne passende Würfelergebnisse = 0
	
	Werte für bereits ausgefüllte orangene Kästchen = 0
	Werte für orangene Kästchen ohne passende Würfelergebnisse = 0
	
	Werte für bereits ausgefüllte lila Kästchen = 0
	Werte für lila Kästchen ohne passende Würfelergebnisse = 0
	
	Werte für Akionen mithilfe ungültiger Würfel = 0
	
	if not Extra Wahl or ungültige Extra Wahl:
		Werte von 122 bis 243 & Wert für das Aussetzen = 0
	if gültige Extra Wahl:
		Werte von 0 bis 121 = 0
		Wert für das Aussetzen = 1
	
	if Neu Würfeln Boni <= 0 or Extra Wahl:
		Wert für Neu Würfel = 0
	
	if einer der Boni zum direkten Ankreuzen von Kästchen >= 1:
		Alle Werte = 0
	
	if Gelbes Kreuz >= 1:
		Werte von 0 bis 15 = 1
	if Blaues Kreuz >= 1:
		Werte von 16 bis 27 = 1
	if Grünes Kreuz >= 1:
		Werte von 28 bis 38 = 1
	if (Orangene Vier or Orangene Fünf or Orangene Sechs) >= 1:
		Werte von 39 bis 49 = 1
	if Lila Sechs >= 1:
		Werte von 50 bis 60 = 1
	
	if Alle Werte außer 246 == 0:
		Wert für ungültige Aktion = 1
	else:
		Wert für ungültige Aktion = 0
		
	return Aktionsmaske
\end{lstlisting}
Code 18: Methode zur Generierung der Aktionsmaske\\

\subsubsection{Methode zum Hinzufügen von Boni}
\begin{minipage}{\linewidth}
Der folgende Pseudocode zeigt die Funktionsweise der Methode zum Hinzufügen von Boni (add\_reward method). Diese Methode wird von der Methode zur Überprüfung der freigespielten Belohnungen genutzt, um Boni dem Inventar des Spielers hinzuzufügen:
\vspace{0.5cm}
\begin{lstlisting}
add_reward(Belohnungstyp):
	Inkrementiere Wert für Belohnungstyp
\end{lstlisting}
Code 19: Methode zum Hinzufügen von Boni\\
\end{minipage}

\subsubsection{Methode zum Inkrementieren von Runden}
Der folgende Pseudocode zeigt die Funktionsweise der Methode zum Inkrementieren von Runden (increment\_rounds method). Diese Methode ist dafür zuständig das Runden-System des Spiels voranzutreiben und zu managen:
\vspace{0.5cm}
\begin{lstlisting}
increment_rounds():
	if Extra Wahl nach eignener Runde:
		Wahl vom Silbertablett = True
		Extra Wahl nach eigener Runde = False
		Setze alle Würfel auf gültig
		Würfele Würfel neu
		Setze drei zufällige Würfel auf ungültig
		
	elif Wahl vom Silbertablett:
		if Extra Wahl Boni >= 1:
			Extra Wahl nach Wahl vom Silbertablett = True
		else:
			Schalte Boni für erreichte Runde frei
			Würfle Würfel neu
		Wahl vom Silbertablett = False
		Setze alle Würfel auf gültig
	
	elif Extra Wahl nach Wahl vom Siblertablett:
		Extra Wahl nach Wahl vom Silbertablett = False
		Würfle Würfel neu
		Setze alle Würfel auf gültig
		Schalte Boni für erreichte Runde frei
	
	elif Wurf in Runde >= 3:
		Rundenanzahl -= 1
		Wurf in Runde = 1
		Setze alle Würfel auf gültig
		if Extra Wahl Boni >= 1:
			Extra Wahl nach eigener Runde = True
		else:
			Wahl vom Silbertablett = True
			Würfle Würfel neu
			Setze drei zufällige Würfel auf ungültig
	else:
		Wurf in Runde += 1
		Würfle Würfel neu
\end{lstlisting}
Code 20: Methode zum Inkrementieren von Runden\\

\subsection{Künstliche Intelligenz}
Die Implementierung besteht aus zwei wesentlichen Klassen. Eine davon ist die Künstliche Intelligenz. In diesem Kapitel werden die Methoden der Künstlichen Intelligenz mithilfe von Pseudocode erläutert. Diese Methoden beinhaltet Methoden der Spielumgebung [siehe Spielumgebung] und Methoden zur Visualisierung, auf die im nächsten Kapitel genauer eingegangen wird.
\subsubsection{Methode zu anlernen des Modells}
\begin{minipage}{\linewidth}
Der folgende Pseudocode zeigt die Funktionsweise der Methode zum anlernen des Modells (model\_learn). Es werden Hyperparameter festgelegt, welche genutzt werden, um ein MaskablePPO Modell zu bilden und mithilfe der Spielumgebung zu trainieren. Alternativ kann ein bereits trainiertes Modell geladen und weiter trainiert werden:
\vspace{0.5cm}
\begin{lstlisting}
model_learn(Hyperparameter):
	Initialisiere Spielumgebungen
	Modell = Initialisiere MaskablePPO Modell mit Hyperparamter
	if Modellname in Hyperparameter:
		Modell = Lade Modell mit Modellname
		Modell.Spielumgebungen = Initialisieren Spielumgebungen
		Setze Entropie Koeffizient
	Lerne Modell an
	Setze Gamma für Vorhersagen
	Setze Entropie Koeffizient für Vorhersagen
	Lerne Modell erneut an
	Speichere Modell
\end{lstlisting}
Code 21: Methode zu anlernen des Modells\\
\end{minipage}
\subsubsection{Methode zum Vorhersagen mithilfe des Modells}
\begin{minipage}{\linewidth}
Der folgende Pseudocode zeigt die Funktionsweise der Methode zum Vorhersagen mithilfe des Modells(model\_predict). Diese Methode ermöglicht es mithilfe des Modells Vorhersagen über günstige Aktionen in einem gegebenen Zustand der Spielumgebung zu bestimmen und anhand dessen, zusammen mit einer solchen Spielumgebung, einen Spielverlauf zu simulieren:
\vspace{0.5cm}
\begin{lstlisting}
model_predict(Schrittanzahl):
	Lade Modell
	Initialisiere Spielumgebungen und Historien
	Setze Beobachtungsraum
	for i in range(Schrittanzahl):
		Aktualisiere Aktionsmaske
		Aktion = Vorhersage der nächsten Aktion
		Führe Aktion in Spielumgebung aus
		Trage Werte in Historien ein
		Visualisiere Spielumgebung
	Plotte Historien
\end{lstlisting}
Code 22: Methode zum Vorhersagen mithilfe des Modells\\
\end{minipage}
\subsubsection{Methode zur Initialisierung der Spielumgebungen}
\begin{minipage}{\linewidth}
Der folgende Pseudocode zeigt die Funktionsweise der Methode zur Initialisierung der Spielumgebungen(\_init\_envs). Mit der Methode werden Spielumgebungen initialisiert und einer Vektorumgebung zugewiesen. Diese Vektorumgebung ermöglicht es mehrere Spielumgebungen gleichzeitig zu bearbeiten. Außerdem werden Variablen für die Nachvollziehbarkeit der Abläufe innerhalb der Spielumgebung (Historien) initialisiert:
\vspace{0.5cm}
\begin{lstlisting}
_init_envs(Anzahl, Punktestände, Fehlversuche):
	_init():
		Spielumgebung = Initialisieren eine Spielumgebung
		Setze Aktionsmasker für die Spielumgebung
		return Spielumgebung
	Initisalisiere Verktorumgebung(Anzahl, _init)
	if not Punkstestände and not Fehlversuche:
		return Vektorumgebung
	if Punktestände and not Fehlversuche:
		Erstelle Variablen für Punkteständehistorie
	if not Punktestände and Fehlversuche:
		Erstelle Variablen für Fehlversuchehistorie
	if Punktestände and Fehlversuche:
		Erstelle Variablen für Punkteständehistorie
		Erstelle Variablen für Fehlversuchehistorie
	return Vektorumgebung, Variablen für Historien
\end{lstlisting}
Code 23: Methode zur Initialisierung der Spielumgebungen\\
\end{minipage}

\subsubsection{Methode zum Anwenden der Aktionsmaske}
\begin{minipage}{\linewidth}
Der folgende Pseudocode zeigt die Funktionsweise der Methode zum Anwenden der Aktionsmaske(mask\_fn). Die Methode dient dazu dem Modell die Aktionsmasken der einzelnen Spielumgebungen zu übergeben:
\vspace{0.5cm}
\begin{lstlisting}
mask_fn(Spielumgebung):
	Caste Spielumgebung in benutzerdefinierte Spielumgebung
	return Aktionsmaske der Spielumgebung
\end{lstlisting}
Code 24: Methode zum Anwenden der Aktionsmaske\\
\end{minipage}

\subsection{Darstellung}
Dieses Kapitel erläutert die Methoden zur Visualisierung mithilfe von Pseudocode.
\subsubsection{Methoden zum Erstellen von Einträgen}
\begin{minipage}{\linewidth}
Der folgende Pseudocode zeigt die Funktionsweise der Methoden zum Erstellen von Einträgen(make\_fail\_entries, make\_score\_entries, make\_fail\_history\_entry, make\_score\_history\_entry). Diese Methoden erstellen Einträgen und Historien von erzielten Punkteständen und der Anzahl getätigter ungültiger Aktionen innerhalb abgeschlossener Spiele:
\vspace{0.5cm}
\begin{lstlisting}
make_fail_entries(Punktebelohnungen, Anzahl, Fehlversuche):
	if Punktebelohnung < 0:
		Inkrementiere Fehlversuche der Umgebung

make_score_entries(Punktebelohnungen, Anzahl, Punktestände):
	if Punktebelohnung > 0:
		Addiere Punktebelohnung zum Punktestand der Umgebung

make_fail_history_entry(Fehlversuche, Fehlversuchshistorie)
	if Umgebung terminiert:
		Hänge Fehlversuche an Fehlversuchshistorie an
		
make_score_history_entry(Punktestände, Punktehistorie)
	if Umgebung terminiert:
		Hänge Punktestand der Umgebung Punktehistorie an
\end{lstlisting}
Code 25: Methoden zum Erstellen von Einträgen\\
\end{minipage}
\subsubsection{Methode zum plotten von Historien}
\begin{minipage}{\linewidth}
Der folgende Pseudocode zeigt die Funktionsweise der Methode zum plotten von Historien(plot\_history). Diese Methode visualisiert die generierten Historien:
\vspace{0.5cm}
\begin{lstlisting}
plot_history(Historie):
	Plotte jeden Eintrag der Historie
	Setze Titel
	Setze Labels
	Zeige Grafik an
\end{lstlisting}
Code 26: Methode zum plotten von Historien\\
\end{minipage}
\subsection{Verwendung}
\begin{minipage}{\linewidth}
Der folgende Code zeigt ein Anwendungsbeispiel des Projektes. Es  wird ein Modell mit dem Namen model\_name geladen und für 1110000 Schritte (x3 durch die learn\_model methode) trainiert. Entsprechende Hyperparameter werden ebenfalls gesetzt. Daraufhin werden mithilfe des Modells Spieldurchläufe (40000 Schritte lang) simuliert:
\vspace{0.5cm}
\begin{lstlisting}
def main():
	model_learn(total_timesteps=1110000, ent_coef=0.1, gamma=1, 
	 model_name="maskableppo_ganzschoenclever_193avg_v3")
	
	model_predict(n_envs=1, render=True, n_steps=40000,
	 model_name="maskableppo_ganzschoenclever")
\end{lstlisting}
Code 27: Anwendungsbeispiel\\
\end{minipage}